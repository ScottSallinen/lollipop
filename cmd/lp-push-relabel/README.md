- A: Always aggregates messages, uses hashtable to store neighbours
  - Best in terms of performance on dynamic graphs
- B: Pure message passing, uses hashtable to store neighbours
- C: Pure message passing, uses array to store neighbours, destination of each edge is treated as a new neighbour
  - Very slow
- D: Pure message passing, uses array to store neighbours, uses hashtable to map internalIds to indexes in the array (no duplicate neighbours)
- E: Based on D, tracks incoming residual capacities
  - Only for analyzing the cost of tracking incoming residual capacities
- F: Based on E, skips sending heights if ResCapIn == 0
- G: Based on F, but use aggregation when sending heights, copies the height array on retrieve
- H: Based on F, but use aggregation when sending heights, locks the height array and pass a reference when updating vertex
- I: Based on F, tracks index of the next push target in discharge
  - Best in terms of performance on static graphs
  - Potential reasons why the performance on dynamic graphs is worse than A:
    - On static graphs, access to the hashtable (mapping from ID to index in array) has better temporal locality
- J: Based on D, tracks index of the next push target in discharge
  - Best when considering the following aspects together: (i) performance on static graphs, (ii) performance on dynamic graphs, and (iii) simplicity
- K: J with global relabeling (async/sync)
- L: K with tracks incoming residual capacities and skips sending heights if ResCapIn == 0
- M: Based on L, reduced Note size, use InitAllNote instead of InitAllMail, better code
